"use strict";
/*
 * eslint-plugin-sonarjs
 * Copyright (C) 2018 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
// https://jira.sonarsource.com/browse/RSPEC-3776
var nodes_1 = require("../utils/nodes");
var locations_1 = require("../utils/locations");
var MESSAGE = "Refactor this function to reduce its Cognitive Complexity from {{complexity}} to the {{threshold}} allowed.";
var DEFAULT_THRESHOLD = 15;
var rule = {
    meta: {
        schema: [{ type: "integer", minimum: 0 }],
    },
    create: function (context) {
        var threshold = context.options[0] !== undefined ? context.options[0] : DEFAULT_THRESHOLD;
        /** Complexity of the current function if it is *not* considered nested to the first level function */
        var complexityIfNotNested = 0;
        /** Complexity of the current function if it is considered nested to the first level function */
        var complexityIfNested = 0;
        /** Current nesting level (number of enclosing control flow statements and functions) */
        var nesting = 0;
        /** Indicator if the current top level function has a structural (generated by control flow statements) complexity */
        var topLevelHasStructuralComplexity = false;
        /** Own (not including nested functions) complexity of the current top function */
        var topLevelOwnComplexity = 0;
        /** Nodes that should increase nesting level  */
        var nestingNodes = new Set();
        /** Set of already considered (with already computed complexity) logical expressions */
        var consideredLogicalExpressions = new Set();
        /** Stack of enclosing functions */
        var enclosingFunctions = [];
        var secondLevelFunctions = [];
        return {
            ":function": function (node) {
                onEnterFunction(node);
            },
            ":function:exit": function (node) {
                onLeaveFunction(node);
            },
            "*": function (node) {
                if (nestingNodes.has(node)) {
                    nesting++;
                }
            },
            "*:exit": function (node) {
                if (nestingNodes.has(node)) {
                    nesting--;
                    nestingNodes.delete(node);
                }
            },
            IfStatement: function (node) {
                visitIfStatement(node);
            },
            ForStatement: function (node) {
                visitLoop(node);
            },
            ForInStatement: function (node) {
                visitLoop(node);
            },
            ForOfStatement: function (node) {
                visitLoop(node);
            },
            DoWhileStatement: function (node) {
                visitLoop(node);
            },
            WhileStatement: function (node) {
                visitLoop(node);
            },
            SwitchStatement: function (node) {
                visitSwitchStatement(node);
            },
            ContinueStatement: function (node) {
                visitContinueOrBreakStatement(node);
            },
            BreakStatement: function (node) {
                visitContinueOrBreakStatement(node);
            },
            CatchClause: function (node) {
                visitCatchClause(node);
            },
            LogicalExpression: function (node) {
                visitLogicalExpression(node);
            },
            ConditionalExpression: function (node) {
                visitConditionalExpression(node);
            },
        };
        function onEnterFunction(node) {
            if (enclosingFunctions.length === 0) {
                // top level function
                topLevelHasStructuralComplexity = false;
                topLevelOwnComplexity = 0;
                secondLevelFunctions = [];
            }
            else if (enclosingFunctions.length === 1) {
                // second level function
                complexityIfNotNested = 0;
                complexityIfNested = 0;
            }
            else {
                nesting++;
                nestingNodes.add(node);
            }
            enclosingFunctions.push(node);
        }
        function onLeaveFunction(node) {
            enclosingFunctions.pop();
            if (enclosingFunctions.length === 0) {
                // top level function
                if (topLevelHasStructuralComplexity) {
                    var totalComplexity_1 = topLevelOwnComplexity;
                    secondLevelFunctions.forEach(function (secondLevelFunction) {
                        totalComplexity_1 += secondLevelFunction.complexityIfNested;
                    });
                    checkFunction(totalComplexity_1, locations_1.getMainFunctionTokenLocation(node, nodes_1.getParent(context), context));
                }
                else {
                    checkFunction(topLevelOwnComplexity, locations_1.getMainFunctionTokenLocation(node, nodes_1.getParent(context), context));
                    secondLevelFunctions.forEach(function (secondLevelFunction) {
                        checkFunction(secondLevelFunction.complexityIfThisSecondaryIsTopLevel, locations_1.getMainFunctionTokenLocation(secondLevelFunction.node, secondLevelFunction.parent, context));
                    });
                }
            }
            else if (enclosingFunctions.length === 1) {
                // second level function
                secondLevelFunctions.push({
                    node: node,
                    parent: nodes_1.getParent(context),
                    complexityIfNested: complexityIfNested,
                    complexityIfThisSecondaryIsTopLevel: complexityIfNotNested,
                    loc: locations_1.getMainFunctionTokenLocation(node, nodes_1.getParent(context), context),
                });
            }
            else {
                // complexity of third+ level functions is computed in their parent functions
                // so we never raise an issue for them
            }
        }
        function visitIfStatement(ifStatement) {
            var parent = nodes_1.getParent(context);
            // if the current `if` statement is `else if`, do not count it in structural complexity
            if (nodes_1.isIfStatement(parent) && parent.alternate === ifStatement) {
                addComplexity();
            }
            else {
                addStructuralComplexity();
            }
            // always increase nesting level inside `then` statement
            nestingNodes.add(ifStatement.consequent);
            // if `else` branch is not `else if` then
            // - increase nesting level inside `else` statement
            // - add +1 complexity
            if (ifStatement.alternate && !nodes_1.isIfStatement(ifStatement.alternate)) {
                nestingNodes.add(ifStatement.alternate);
                addComplexity();
            }
        }
        function visitLoop(loop) {
            addStructuralComplexity();
            nestingNodes.add(loop.body);
        }
        function visitSwitchStatement(switchStatement) {
            addStructuralComplexity();
            for (var _i = 0, _a = switchStatement.cases; _i < _a.length; _i++) {
                var switchCase = _a[_i];
                nestingNodes.add(switchCase);
            }
        }
        function visitContinueOrBreakStatement(statement) {
            if (statement.label) {
                addComplexity();
            }
        }
        function visitCatchClause(catchClause) {
            addStructuralComplexity();
            nestingNodes.add(catchClause.body);
        }
        function visitConditionalExpression(conditionalExpression) {
            addStructuralComplexity();
            nestingNodes.add(conditionalExpression.consequent);
            nestingNodes.add(conditionalExpression.alternate);
        }
        function visitLogicalExpression(logicalExpression) {
            if (!consideredLogicalExpressions.has(logicalExpression)) {
                var flattenedLogicalExpressions = flattenLogicalExpression(logicalExpression);
                var previous = void 0;
                for (var _i = 0, flattenedLogicalExpressions_1 = flattenedLogicalExpressions; _i < flattenedLogicalExpressions_1.length; _i++) {
                    var current = flattenedLogicalExpressions_1[_i];
                    if (!previous || previous.operator !== current.operator) {
                        addComplexity();
                    }
                    previous = current;
                }
            }
        }
        function flattenLogicalExpression(node) {
            if (nodes_1.isLogicalExpression(node)) {
                consideredLogicalExpressions.add(node);
                return flattenLogicalExpression(node.left).concat([node], flattenLogicalExpression(node.right));
            }
            return [];
        }
        function addStructuralComplexity() {
            var added = nesting + 1;
            if (enclosingFunctions.length === 1) {
                // top level function
                topLevelHasStructuralComplexity = true;
                topLevelOwnComplexity += added;
            }
            else {
                // second+ level function
                complexityIfNested += added + 1;
                complexityIfNotNested += added;
            }
        }
        function addComplexity() {
            if (enclosingFunctions.length === 1) {
                // top level function
                topLevelOwnComplexity++;
            }
            else {
                // second+ level function
                complexityIfNested++;
                complexityIfNotNested++;
            }
        }
        function checkFunction(complexity, loc) {
            if (complexity > threshold) {
                context.report({
                    message: MESSAGE,
                    data: { complexity: String(complexity), threshold: String(threshold) },
                    loc: loc,
                });
            }
        }
    },
};
module.exports = rule;
//# sourceMappingURL=cognitive-complexity.js.map